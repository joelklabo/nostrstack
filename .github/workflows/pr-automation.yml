name: ðŸ”„ PR Automation

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]

permissions:
  pull-requests: write
  contents: read

jobs:
  pr-metadata:
    name: PR Metadata & Labels
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Auto-label by file paths
        uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/labeler.yml

      - name: Check PR size
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const additions = pr.additions;
            const deletions = pr.deletions;
            const changes = additions + deletions;

            let size = 'xs';
            let color = '0e8a16'; // green
            let emoji = 'ðŸŸ¢';

            if (changes > 1000) {
              size = 'xl';
              color = 'd93f0b'; // red
              emoji = 'ðŸ”´';
            } else if (changes > 500) {
              size = 'l';
              color = 'fbca04'; // yellow
              emoji = 'ðŸŸ¡';
            } else if (changes > 100) {
              size = 'm';
              color = '0366d6'; // blue
              emoji = 'ðŸ”µ';
            } else if (changes > 30) {
              size = 's';
              color = '0e8a16'; // green
              emoji = 'ðŸŸ¢';
            }

            // Remove old size labels
            const oldSizeLabels = ['size/xs', 'size/s', 'size/m', 'size/l', 'size/xl'];
            for (const label of oldSizeLabels) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  name: label
                });
              } catch (e) {
                // Label might not exist, that's ok
              }
            }

            // Add new size label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: [`size/${size}`]
            });

            // Comment if PR is too large
            if (changes > 500) {
              const sizeLabelText = 'size/' + size;
              const comment = '## ' + emoji + ' Large PR Warning\n\n' +
                'This PR has **' + changes.toLocaleString() + ' lines changed** (+' +
                additions.toLocaleString() + ', -' + deletions.toLocaleString() + ').\n\n' +
                'Large PRs are harder to review and more likely to introduce bugs. Consider:\n' +
                '- Breaking this into smaller, focused PRs\n' +
                '- Separating refactoring from feature changes\n' +
                '- Moving generated files or large data to a separate PR\n\n' +
                '**Size label:** `' + sizeLabelText + '`';

              // Check if we already commented
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });

              const botComment = comments.find(c =>
                c.user.type === 'Bot' &&
                c.body.includes('Large PR Warning')
              );

              if (!botComment) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: comment
                });
              }
            }

      - name: Check for linked issues
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const body = pr.body || '';

            const issueRefPattern = /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s+#(\d+)/gi;
            const issueRefsFromText = (text = '') => {
              const refs = new Set();
              for (const match of text.matchAll(issueRefPattern)) {
                const num = Number(match[1]);
                if (Number.isFinite(num) && num > 0) refs.add(num);
              }
              return Array.from(refs);
            };

            const issueMetadataFromCommit = async () => {
              const fallbackRefs = new Set();
              const commits = await github.paginate(github.rest.pulls.listCommits, {
                owner,
                repo,
                pull_number: pr.number,
                per_page: 100
              });
              for (const commit of commits || []) {
                const message = (commit.commit && commit.commit.message) || '';
                for (const ref of issueRefsFromText(message)) {
                  fallbackRefs.add(ref);
                }
              }
              return Array.from(fallbackRefs);
            };

            const resolveIssueMetadata = async (issueNumber) => {
              try {
                const { data } = await github.rest.issues.get({
                  owner,
                  repo,
                  issue_number: issueNumber
                });
                return {
                  issueNumber,
                  ok: true,
                  title: String(data.title || '').trim() || '(untitled issue)',
                  state: data.state || 'unknown'
                };
              } catch (error) {
                return {
                  issueNumber,
                  ok: false,
                  title: '(unresolved)',
                  state: 'unknown',
                  error: String(error?.status || error?.message || error)
                };
              }
            };

            const bodyIssueRefs = issueRefsFromText(body);
            const hasExplicitIssueRefs = bodyIssueRefs.length > 0;
            const usingCommitFallback = !hasExplicitIssueRefs;
            const fallbackIssueRefs = usingCommitFallback ? await issueMetadataFromCommit() : [];

            const explicitOrFallbackRefs = hasExplicitIssueRefs ? bodyIssueRefs : fallbackIssueRefs;
            const needsFallback =
              !hasExplicitIssueRefs &&
              fallbackIssueRefs.length > 0 &&
              !body.includes('no-issue-needed');

            const issueMeta = await Promise.all(
              explicitOrFallbackRefs.map((issueNumber) => resolveIssueMetadata(issueNumber))
            );
            const missingMetadata = issueMeta.filter((entry) => !entry.ok);
            const staleMetadata = issueMeta.filter((entry) => entry.ok && entry.state !== 'open');
            const resolvedMetadata = issueMeta.filter((entry) => entry.ok);

            const isFallbackAmbiguous =
              usingCommitFallback &&
              fallbackIssueRefs.length > 1;
            const isFallbackMissing = needsFallback && fallbackIssueRefs.length === 0;
            const hasResolvedFallback = usingCommitFallback && resolvedMetadata.length === 1;
            const hasUnusableFallback =
              usingCommitFallback &&
              (isFallbackMissing ||
                missingMetadata.length > 0 ||
                isFallbackAmbiguous ||
                (hasResolvedFallback && staleMetadata.length > 0));
            const hasExplicitMetadataLoadFailure =
              hasExplicitIssueRefs &&
              missingMetadata.length > 0;

            if (!body.includes('no-issue-needed') && (!hasExplicitIssueRefs || hasUnusableFallback || hasExplicitMetadataLoadFailure)) {
              const sortedFallback = fallbackIssueRefs.map(String).sort().join(', ');
              const sortedMeta = issueMeta.map((entry) => `#${entry.issueNumber}: ${entry.title}`).join('\n');

              let comment = '## âš ï¸ Missing Issue Reference\n\n';
              if (hasExplicitMetadataLoadFailure) {
                const missingList = missingMetadata.map((entry) => `#${entry.issueNumber}`).join(', ');
                comment += `I found direct issue reference(s) in the PR body (${missingList}), but couldn't load issue metadata from GitHub.\n\n`;
                comment += 'Please confirm these issue numbers still exist and are accessible to repository automation.\n';
              } else if (isFallbackMissing) {
                comment += 'No issue reference keywords like `Fixes #123` were found in this PR body, and no issue references were found in commit metadata.\n\n';
              } else if (isFallbackAmbiguous) {
                comment += `I found multiple possible issue references in commit metadata: \`${sortedFallback}\`.\n\nThis fallback path is ambiguous, so I can't reliably attach a single issue.\n`;
              } else if (missingMetadata.length > 0) {
                const missingList = missingMetadata.map((entry) => `#${entry.issueNumber}`).join(', ');
                comment += `I found fallback issue metadata candidates (${missingList}) but could not load issue details from GitHub.\n\n`;
                comment += 'Fallback paths can become stale when issue numbers are removed, moved, or no longer accessible.\n';
              } else if (staleMetadata.length > 0) {
                const staleList = staleMetadata.map((entry) => `#${entry.issueNumber} (${entry.state})`).join(', ');
                comment += `I resolved this PR to commit-metadata fallback issue(s) ${staleList}, but these are not currently open.\n\n`;
                comment += 'Commit metadata may be stale, so please confirm or add a direct PR issue reference.\n';
              } else {
                comment += `I couldn't find a direct issue reference in the PR body, but I found commit metadata for: \n\`\`\`\n${sortedMeta}\n\`\`\`\n`;
                comment += 'If commit-based metadata is intentional, it may become stale on rebases; please add `Fixes #123`/`Closes #456` in the PR description for stability.\n';
              }

              comment += '\nPlease add one of:\n' +
                '- `Fixes #123` / `Closes #456` in the PR body\n' +
                '- Or `no-issue-needed` if no issue is required\n\n' +
                'This helps track changes and gives reviewers stable context.\n';

              const { data: comments } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: pr.number
              });

              const botComment = comments.find(c =>
                c.user.type === 'Bot' &&
                c.body.includes('Missing Issue Reference')
              );

              if (!botComment) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: comment
                });
              }
            }

      - name: Check for breaking changes
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title.toLowerCase();
            const body = (pr.body || '').toLowerCase();

            const hasBreakingIndicator =
              title.includes('breaking') ||
              title.includes('!:') ||
              body.includes('breaking change') ||
              body.includes('breaking-change');

            if (hasBreakingIndicator) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['breaking-change']
              });
            }
